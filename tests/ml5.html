<html>
  <head>
    <meta charset="UTF-8" />
    <title>HandPose — Left Hand Only</title>
    <script
      src="https://unpkg.com/ml5@latest/dist/ml5.min.js"
      type="text/javascript"
    ></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      #video {
        display: none;
      }
    </style>
  </head>

  <body>
    <video id="video" width="640" height="480" autoplay playsinline></video>
    <canvas
      id="videoCanvas"
      width="300"
      height="220"
      style="
        position: absolute;
        right: 12px;
        top: 80px;
        width: 300px;
        height: 220px;
        border: 2px solid rgba(0, 0, 0, 0.6);
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.4);
        z-index: 60;
        pointer-events: none;
      "
    ></canvas>

    <script>
      const canvas = document.getElementById("videoCanvas");
      const ctx = canvas.getContext("2d");

      const W = canvas.width;
      const H = canvas.height;

      let handPose;
      let hands = [];
      let video;

      async function preload() {
        video = await getVideo();

        // load the model
        handPose = await ml5.handPose({ flipped: true });

        // start detecting hands from the webcam video
        await handPose.detectStart(video, gotHands);

        render();
      }

      window.addEventListener("DOMContentLoaded", preload);

      function gotHands(results) {
        hands = results;
      }

      let circleX = W / 2;
      let circleY = H / 2;
      const smoothing = 0.2;

      function render() {
        ctx.clearRect(0, 0, W, H);

        // draw mirrored video
        ctx.save();
        ctx.translate(W, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(video, 0, 0, W, H);
        ctx.restore();

        // overlay
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fillRect(0, 0, W, H);

        if (hands.length > 0) {
          // Se há mais de uma mão, escolhe a mais à esquerda (menor média de X)
          let leftMostHand = hands.reduce((left, current) => {
            const leftAvgX =
              left.keypoints.reduce((sum, kp) => sum + kp.x, 0) /
              left.keypoints.length;
            const currentAvgX =
              current.keypoints.reduce((sum, kp) => sum + kp.x, 0) /
              current.keypoints.length;
            return currentAvgX < leftAvgX ? current : left;
          });

          // encontrar o ponto da ponta do dedo indicador
          const indexTip = leftMostHand.keypoints.find(
            (kp) => kp.name === "index_finger_tip"
          );

          if (indexTip) {
            ctx.fillStyle = "#863228";
            ctx.beginPath();
            ctx.arc(indexTip.x, indexTip.y, 10, 0, 2 * Math.PI);
            ctx.fill();

            circleX += (indexTip.x - circleX) * smoothing;
            circleY += (indexTip.y - circleY) * smoothing;
          }
        }

        // círculo suave
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(circleX, circleY, 5, 0, 2 * Math.PI);
        ctx.fill();

        requestAnimationFrame(render);
      }

      async function getVideo() {
        const videoElement = document.getElementById("video");
        videoElement.width = W;
        videoElement.height = H;

        const capture = await navigator.mediaDevices.getUserMedia({
          video: true,
        });
        videoElement.srcObject = capture;
        videoElement.play();

        return videoElement;
      }
    </script>
  </body>
</html>
